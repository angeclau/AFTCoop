% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/aft_coop.R
\name{aft_coop}
\alias{aft_coop}
\title{Cooperative Estimation with AFT Survival Models}
\usage{
aft_coop(
  U,
  Z,
  Y,
  delta,
  sigma,
  nfolds = 5,
  model,
  case,
  rho_values,
  lam_min,
  nlambda = 100,
  lambda.ratio.min = 0.01,
  parallel = TRUE,
  ncore_max_rho = 4,
  ncore_max_cv = 5,
  seed = 123,
  iplot = T,
  addbar = F
)
}
\arguments{
\item{U}{Matrix of covariates correspondig to the first view (e.g., gene expression) of dimension \code{n x p_u}, where \code{n} is the number of samples and \code{p_u} is the number of variables in the first view.}

\item{Z}{Matrix of covariates correspondig to the second view (e.g., gene methylation) of dimension \code{n x p_z},where \code{n} is the number of samples and \code{p_z} is the number of variables in the second view.}

\item{Y}{Vector of log observed survival times or log censored times (i.e., the response variables are in log scale) of dimension \code{n}, where \code{n} is the number of samples.}

\item{delta}{Vector of censoring indicators (1 for event, 0 for censored) of dimension  \code{n}, where \code{n} is the number of samples.}

\item{sigma}{Scale parameter for the AFT model (it must be a positive real value).}

\item{nfolds}{Number of folds to use for the cross-validation (default: 5)}

\item{model}{Character string specifying the specific AFT model to use.  It can assume one of the following values "weibull";"lognormal";"loglogistic".
The noise distribution in the log time models  \eqn{Y=X \beta+\sigma \epsilon} can be Extreme Value Gumbel distribution that corresponds to the "weibull" model, normal distribution that correspond to the  "lognormal" model, and logistic distribution that correspond to the "loglogistic" model.}

\item{case}{Character string specifying the data model. It can take the following values: "onlyU","onlyZ","coop". The choice "onlyU" uses only the first view of covariates,
The choice "onlyZ" uses only the second view of covariates, The choice "coop" uses both views as covariates.}

\item{rho_values}{Vector of \code{nrhos} cooperation parameters. The  \code{nrhos} parameters are relevant only when case="coop" and allow different tuning of the coperative and Lasso penalization terms. When case="onlyU" or case="onlyZ", the parameter is not relevant and it is set to 1.}

\item{lam_min}{Logical; if TRUE uses lambda.min, if FALSE uses lambda.1se}

\item{nlambda}{Number of lambda values in regularization path (default: 100)}

\item{lambda.ratio.min}{Minimum ratio of smallest to largest lambda (default: 0.01)}

\item{parallel}{Logical; enable parallel processing (default: TRUE)}

\item{ncore_max_rho}{Maximum number of cores for parallel processing for splitting over rho_values (default: 4)}

\item{ncore_max_cv}{Maximum number of cores for parallel processing for splitting over Cross-validation (default: 5)}

\item{seed}{Random seed for reproducibility (default: 123)}

\item{iplot}{Logical; enable the plot of the CV function (default: TRUE)}

\item{addbar}{Logical; when iplot is true, add the error bar to the plot (default: FALSE)}
}
\value{
A matrix of dimension \code{(p_u+p_z)x nrhos},where:
\itemize{
\item Rows correspond to the estimates regression coefficients \eqn{\hat{\beta}=[\hat{\beta}_u,\hat{\beta}_z]} for each view.
\item Columns correspond to the estimates for different rho values
\item Values are coefficient \eqn{\hat{\beta}} in original scale.
The first set of coefficients corresponds \eqn{\hat{\beta}_u} to those associated with the \code{U} view, the second set \eqn{\hat{\beta_z}} to those associated to the view  \code{Z}.
}
}
\description{
The function aft_coop implements a cooperative estimation method for Accelerated Failure Time (AFT) models
allowing to integrate two matrices \code{U} and \code{Z} of high-dimensional covariates.
The two matrices  \code{U} and \code{Z} can represent two omics views, such as gene expression and methylation.
When used with two matrices  \code{U} and \code{Z}, the function estimates the coefficients \eqn{\beta_u} and \eqn{\beta_z}
associated with the two views by solving the minimization problem using the proximal gradient descend algorithm.
In such a case, the minimization problem consists of three terms: the negative log-likelihood, the agreement term among the two views,
and the Lasso penalization for each view.
However, the function works also with a single matrix  \code{U} or \code{Z}.
In such cases, it performs negative log-likelihood minimization with the Lasso penalty.
In both cases, cross-validation estimates the regularization parameter.
The function supports parallel processing and cross-validation for optimal parameter selection.
}
\details{
When providing two matrices \code{U} and \code{Z}, the function aft_coop performs the following steps:
\itemize{
\item Build combined matrix \code{X=[U;Z]} and \code{Xtilde=[U;-Z]}, given the two matrices \code{U} and \code{Z}
\item Standardizes \code{U} and \code{Z}  matrices.
\item Generates lambda grid and initialize the search using gradient at initial estimate \eqn{\beta = 0}.
\item For each rho value:
\itemize{
\item Performs K-fold cross-validation to select optimal lambda
\item Computes cooperative matrix
\item Applies proximal gradient descent
\item Rescales coefficients back to original scale
}
}
The function uses standardized variables internally but returns coefficients
in the original scale. Cross-validation is used to select optimal lambda values.
The user can choose the optimal value for lambda as lambda.min (i.e., the values of lambda for which the CV is minimised)
or lambda.1se (i.e, the largests value of lambda within 1 standard error form the the minumum).
The latter choice provides a sparsest model.
The choice of the type of optimal value to use is done setting the logical lam_min parameter.
However, we switch between  lambda.min  and lambda.1se is the correspondoing values is at the boarder of the grid interval.
Parallel processing implementation differs between Windows (using makeCluster)
and Unix-like systems (using mclapply).
}
\note{
Last change 15/04/2025
}
\examples{
\dontrun{
# Generate example data
set.seed(123)
model="weibull"
data <- generate_data(
  model = model,
    n = 200,
    pu = 150,
    pz = 150,
    tu = 6,
    tz = 6,
    rate = 40,
    sigma_true = 0.5
    )

    Y <- data$Y  # vector of log survival times or censored times
    delta <- data$delta  # vector of censoring indicators
    U <- data$U  # matrix corresponding to the first view
    Z <- data$Z  # matrix corresponding to the second view
    fit_survreg <- survreg(Surv(data$times_c, delta)~1, dist=model,scale=0)
    sigma.est <- exp(fit_survreg$icoef[2])
    rho_values<- c(1,0.25,0.5,0.75) #vector parameteters for rho values
# Using aft_coop with two views
    beta_est_coop<-aft_coop(
    U=U,
    Z=Z,
    Y=Y,
    delta=delta,
    sigma=sigma.est,
    nfolds=5,
    model=model,
    case="coop",
    rho_values=  rho_values,
    lam_min=F,
    parallel=T,
    ncore_max=5,
    seed=123)

   ## estimate of beta  (the first pu components refers to the view U; The second pz component to view Z  )
   beta_est_coop

# Using aft_coop with only the first view U
    beta_est_onlyU<-aft_coop(
    U=U,
    Z=Z,
    Y=Y,
    delta=delta,
    sigma=sigma.est,
    nfolds=5,
    model=model,
    case="onlyU",
    rho_values=  1,
    lam_min=F,
    parallel=T,
    ncore_max=5,
    seed=123)


## Using aft_coop with only the second view
 beta_est_onlyZ<-aft_coop(
    U=U,
    Z=Z,
    Y=Y,
    delta=delta,
    sigma=sigma.est,
    nfolds=5,
    model=model,
    case="onlyZ",
    rho_values=  1,
    lam_min=F,
    parallel=T,
    ncore_max=5,
    seed=123)

    beta_est_onlyZ
}


}
\references{
Angelini, De Canditiis, De Feis, Iuliano (in prep. 2025).

Ding, Li, Narasimhan, Tibshirani, "Cooperative learning for multiview analysis", PNAS (2022)
DOI: 10.1073/pnas.220211311
Available at: \url{https://www.pnas.org/doi/abs/10.1073/pnas.2202113119}
}
\seealso{
\code{\link{cv.coop}} for underlying implementation details
}
